<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Ecosystem Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0d1117 0%, #0a0a0f 100%);
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .title-overlay h1 {
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: linear-gradient(90deg, #00ff88, #00ccff, #00ff88);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .title-overlay .subtitle {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.2em;
            margin-top: 5px;
        }

        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
            min-width: 180px;
        }

        .stats-panel h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .stat-value.herbivores { color: #00ff88; }
        .stat-value.predators { color: #ff4444; }
        .stat-value.food { color: #ffaa00; }
        .stat-value.generation { color: #00ccff; }
        .stat-value.oldest { color: #ff88ff; }

        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .btn:hover {
            background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.primary {
            background: linear-gradient(145deg, #00ff88, #00cc66);
            border-color: #00ff88;
            color: #0a0a0f;
        }

        .btn.primary:hover {
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.4);
        }

        .btn.danger {
            background: linear-gradient(145deg, #ff4444, #cc3333);
            border-color: #ff4444;
            color: #fff;
        }

        .btn.danger:hover {
            box-shadow: 0 4px 20px rgba(255, 68, 68, 0.4);
        }

        .btn.warning {
            background: linear-gradient(145deg, #ffaa00, #cc8800);
            border-color: #ffaa00;
            color: #0a0a0f;
        }

        .btn.warning:hover {
            box-shadow: 0 4px 20px rgba(255, 170, 0, 0.4);
        }

        /* Help Tooltip */
        .help-tooltip {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .help-tooltip.visible {
            opacity: 1;
        }

        .help-tooltip span {
            margin: 0 10px;
        }

        .help-tooltip .key {
            color: #00ff88;
            font-weight: 600;
        }

        /* Species Legend */
        .legend {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
        }

        .legend h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.85rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        .legend-dot.herbivore { background: #00ff88; color: #00ff88; }
        .legend-dot.predator { background: #ff4444; color: #ff4444; }
        .legend-dot.berry { background: #ffaa00; color: #ffaa00; }
        .legend-dot.fruit { background: #ff66aa; color: #ff66aa; }

        /* Responsive */
        @media (max-width: 768px) {
            .title-overlay h1 {
                font-size: 1.2rem;
            }
            .stats-panel {
                top: auto;
                bottom: 100px;
                left: 10px;
                padding: 12px 16px;
                min-width: 150px;
            }
            .legend {
                top: 80px;
                right: 10px;
                padding: 12px 16px;
            }
            .control-panel {
                bottom: 10px;
                padding: 10px 15px;
                gap: 8px;
            }
            .btn {
                padding: 8px 12px;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <h1>Lumina Ecosystem</h1>
        <div class="subtitle">Living Digital World Simulation</div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <h3>Ecosystem Stats</h3>
        <div class="stat-row">
            <span class="stat-label">Herbivores</span>
            <span class="stat-value herbivores" id="herbivore-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Predators</span>
            <span class="stat-value predators" id="predator-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Food</span>
            <span class="stat-value food" id="food-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Generation</span>
            <span class="stat-value generation" id="generation-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Oldest</span>
            <span class="stat-value oldest" id="oldest-creature">0s</span>
        </div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <h3>Species</h3>
        <div class="legend-item">
            <div class="legend-dot herbivore"></div>
            <span>Herbivore</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot predator"></div>
            <span>Predator</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot berry"></div>
            <span>Berry (+15)</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot fruit"></div>
            <span>Fruit (+35)</span>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <button class="btn primary" id="btn-pause">Pause</button>
        <button class="btn" id="btn-reset">Reset</button>
        <button class="btn" id="btn-herbivore">+ Herbivore</button>
        <button class="btn danger" id="btn-predator">+ Predator</button>
    </div>

    <!-- Help Tooltip -->
    <div class="help-tooltip visible" id="help-tooltip">
        <span><span class="key">Click</span> spawn food</span>
        <span><span class="key">Drag</span> create wind</span>
    </div>

    <script>
        // ============================================
        // DIGITAL ECOSYSTEM SIMULATION
        // A living artificial world with autonomous agents
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const CONFIG = {
            INITIAL_HERBIVORES: 15,
            INITIAL_PREDATORS: 3,
            INITIAL_FOOD: 30,
            MAX_FOOD: 80,
            FOOD_SPAWN_RATE: 0.05,
            WORLD_WIDTH: 0,
            WORLD_HEIGHT: 0,
            TRAIL_LENGTH: 15,
            ENERGY_DECAY_HERBIVORE: 0.08,
            ENERGY_DECAY_PREDATOR: 0.12,
            REPRODUCTION_THRESHOLD: 80,
            REPRODUCTION_COST: 40,
            FOOD_ENERGY_BERRY: 15,
            FOOD_ENERGY_FRUIT: 35,
            PREDATOR_DAMAGE: 25,
            VIEW_RADIUS_HERBIVORE: 100,
            VIEW_RADIUS_PREDATOR: 150,
            FLEE_RADIUS: 80,
            HUNT_RADIUS: 120,
            MAX_SPEED_HERBIVORE: 2.5,
            MAX_SPEED_PREDATOR: 3.2,
            MAX_FORCE: 0.15,
            WIND_DECAY: 0.95,
            WIND_STRENGTH: 0.5
        };

        // Simulation state
        let isPaused = false;
        let frameCount = 0;
        let generation = 1;
        let oldestCreatureAge = 0;
        let mouseX = 0;
        let mouseY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let windField = [];

        // Entity arrays
        let herbivores = [];
        let predators = [];
        let foods = [];
        let particles = [];

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max));
        }

        function distance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= Math.PI * 2;
            while (angle < -Math.PI) angle += Math.PI * 2;
            return angle;
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // ============================================
        // VECTOR UTILITY
        // ============================================

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }

            sub(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }

            mult(n) {
                return new Vector(this.x * n, this.y * n);
            }

            div(n) {
                return new Vector(this.x / n, this.y / n);
            }

            mag() {
                return Math.hypot(this.x, this.y);
            }

            normalize() {
                const m = this.mag();
                if (m === 0) return new Vector(0, 0);
                return this.div(m);
            }

            limit(max) {
                if (this.mag() > max) {
                    return this.normalize().mult(max);
                }
                return new Vector(this.x, this.y);
            }

            heading() {
                return Math.atan2(this.y, this.x);
            }

            static fromAngle(angle) {
                return new Vector(Math.cos(angle), Math.sin(angle));
            }

            copy() {
                return new Vector(this.x, this.y);
            }
        }

        // ============================================
        // PARTICLE SYSTEM (for effects)
        // ============================================

        class Particle {
            constructor(x, y, color, speed, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = random(-speed, speed);
                this.vy = random(-speed, speed);
                this.life = life;
                this.maxLife = life;
                this.size = random(2, 5);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.size *= 0.98;
                return this.life > 0;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function spawnParticles(x, y, color, count = 8, speed = 3) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, speed, randomInt(20, 40)));
            }
        }

        // ============================================
        // FOOD SYSTEM
        // ============================================

        class Food {
            constructor(x, y, type = 'berry') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.energy = type === 'berry' ? CONFIG.FOOD_ENERGY_BERRY : CONFIG.FOOD_ENERGY_FRUIT;
                this.size = type === 'berry' ? 4 : 7;
                this.pulse = random(0, Math.PI * 2);
                this.color = type === 'berry' ? '#ffaa00' : '#ff66aa';
                this.glowColor = type === 'berry' ? 'rgba(255, 170, 0, 0.5)' : 'rgba(255, 102, 170, 0.5)';
            }

            update() {
                this.pulse += 0.05;
            }

            draw(ctx) {
                const pulseSize = this.size + Math.sin(this.pulse) * 1;
                
                // Glow
                ctx.save();
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Inner core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function spawnFood(x, y, type = null) {
            if (!type) {
                type = Math.random() < 0.7 ? 'berry' : 'fruit';
            }
            foods.push(new Food(x, y, type));
        }

        function spawnRandomFood() {
            if (foods.length >= CONFIG.MAX_FOOD) return;
            const margin = 50;
            const x = random(margin, CONFIG.WORLD_WIDTH - margin);
            const y = random(margin, CONFIG.WORLD_HEIGHT - margin);
            spawnFood(x, y);
        }

        // ============================================
        // WIND FIELD
        // ============================================

        class WindField {
            constructor() {
                this.cells = [];
                this.cellSize = 50;
                this.cols = 0;
                this.rows = 0;
            }

            init() {
                this.cols = Math.ceil(CONFIG.WORLD_WIDTH / this.cellSize);
                this.rows = Math.ceil(CONFIG.WORLD_HEIGHT / this.cellSize);
                this.cells = new Array(this.cols * this.rows).fill(null).map(() => new Vector(0, 0));
            }

            getCellIndex(x, y) {
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return -1;
                return row * this.cols + col;
            }

            addWind(x, y, vx, vy, radius = 100) {
                for (let i = 0; i < this.cells.length; i++) {
                    const col = i % this.cols;
                    const row = Math.floor(i / this.cols);
                    const cx = col * this.cellSize + this.cellSize / 2;
                    const cy = row * this.cellSize + this.cellSize / 2;
                    const dist = distance(x, y, cx, cy);
                    if (dist < radius) {
                        const force = (1 - dist / radius) * CONFIG.WIND_STRENGTH;
                        this.cells[i].x += vx * force;
                        this.cells[i].y += vy * force;
                    }
                }
            }

            getWindAt(x, y) {
                const idx = this.getCellIndex(x, y);
                if (idx >= 0) {
                    return this.cells[idx].copy();
                }
                return new Vector(0, 0);
            }

            update() {
                for (let cell of this.cells) {
                    cell.x *= CONFIG.WIND_DECAY;
                    cell.y *= CONFIG.WIND_DECAY;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i < this.cells.length; i++) {
                    const wind = this.cells[i];
                    if (wind.mag() < 0.01) continue;
                    const col = i % this.cols;
                    const row = Math.floor(i / this.cols);
                    const x = col * this.cellSize + this.cellSize / 2;
                    const y = row * this.cellSize + this.cellSize / 2;
                    const len = wind.mag() * 30;
                    const angle = wind.heading();
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // ============================================
        // CREATURE BASE CLASS
        // ============================================

        class Creature {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = random(-1, 1);
                this.vy = random(-1, 1);
                this.energy = 50;
                this.maxEnergy = 100;
                this.age = 0;
                this.birthTime = Date.now();
                this.generation = 1;
                this.trail = [];
                this.id = Math.random().toString(36).substr(2, 9);
                
                // Perception
                this.viewRadius = type === 'herbivore' ? CONFIG.VIEW_RADIUS_HERBIVORE : CONFIG.VIEW_RADIUS_PREDATOR;
                this.maxSpeed = type === 'herbivore' ? CONFIG.MAX_SPEED_HERBIVORE : CONFIG.MAX_SPEED_PREDATOR;
                
                // Visual properties
                this.baseColor = type === 'herbivore' ? '#00ff88' : '#ff4444';
                this.glowColor = type === 'herbivore' ? 'rgba(0, 255, 136, 0.6)' : 'rgba(255, 68, 68, 0.6)';
                this.size = type === 'herbivore' ? 8 : 10;
                this.pulse = random(0, Math.PI * 2);
            }

            get position() {
                return new Vector(this.x, this.y);
            }

            get velocity() {
                return new Vector(this.vx, this.vy);
            }

            set velocity(v) {
                this.vx = v.x;
                this.vy = v.y;
            }

            updateTrail() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > CONFIG.TRAIL_LENGTH) {
                    this.trail.shift();
                }
            }

            applyForce(force) {
                this.vx += force.x;
                this.vy += force.y;
            }

            // Simple neural decision making
            makeDecision(environment) {
                const forces = [];

                // 1. Wander behavior (default)
                const wanderAngle = this.velocity.heading() + random(-0.5, 0.5);
                const wanderForce = Vector.fromAngle(wanderAngle).mult(0.5);
                forces.push({ force: wanderForce, weight: 0.3 });

                // 2. Seek food if hungry
                if (environment.food && this.energy < 60) {
                    const foodDir = environment.food.sub(this.position).normalize();
                    const foodForce = foodDir.mult(1.0);
                    forces.push({ force: foodForce, weight: 0.8 });
                }

                // 3. Flee from threats
                if (environment.threats.length > 0) {
                    let fleeForce = new Vector(0, 0);
                    for (const threat of environment.threats) {
                        const away = this.position.sub(threat).normalize();
                        const dist = distance(this.x, this.y, threat.x, threat.y);
                        const weight = 1 - (dist / CONFIG.FLEE_RADIUS);
                        fleeForce = fleeForce.add(away.mult(weight));
                    }
                    forces.push({ force: fleeForce.normalize().mult(1.5), weight: 1.0 });
                }

                // 4. Hunt prey (predators only)
                if (this.type === 'predator' && environment.prey) {
                    const preyDir = environment.prey.sub(this.position).normalize();
                    const huntForce = preyDir.mult(1.2);
                    forces.push({ force: huntForce, weight: 0.9 });
                }

                // 5. Avoid boundaries
                const margin = 50;
                let boundaryForce = new Vector(0, 0);
                if (this.x < margin) boundaryForce.x = 1;
                if (this.x > CONFIG.WORLD_WIDTH - margin) boundaryForce.x = -1;
                if (this.y < margin) boundaryForce.y = 1;
                if (this.y > CONFIG.WORLD_HEIGHT - margin) boundaryForce.y = -1;
                if (boundaryForce.mag() > 0) {
                    forces.push({ force: boundaryForce.normalize().mult(1.0), weight: 0.7 });
                }

                // 6. Wind influence
                if (environment.wind) {
                    forces.push({ force: environment.wind.mult(0.5), weight: 0.4 });
                }

                // Combine forces
                let finalForce = new Vector(0, 0);
                for (const { force, weight } of forces) {
                    finalForce = finalForce.add(force.mult(weight));
                }

                return finalForce.normalize().mult(CONFIG.MAX_FORCE);
            }

            perceive() {
                const environment = {
                    food: null,
                    threats: [],
                    prey: null,
                    wind: windField.getWindAt(this.x, this.y)
                };

                let closestFood = null;
                let closestFoodDist = this.viewRadius;

                // Find closest food
                for (const food of foods) {
                    const dist = distance(this.x, this.y, food.x, food.y);
                    if (dist < closestFoodDist) {
                        closestFoodDist = dist;
                        closestFood = food;
                    }
                }
                if (closestFood) {
                    environment.food = new Vector(closestFood.x, closestFood.y);
                }

                if (this.type === 'herbivore') {
                    // Herbivores flee from predators
                    for (const predator of predators) {
                        const dist = distance(this.x, this.y, predator.x, predator.y);
                        if (dist < CONFIG.FLEE_RADIUS) {
                            environment.threats.push(new Vector(predator.x, predator.y));
                        }
                    }
                } else {
                    // Predators hunt herbivores
                    let closestPrey = null;
                    let closestPreyDist = CONFIG.HUNT_RADIUS;
                    for (const herbivore of herbivores) {
                        const dist = distance(this.x, this.y, herbivore.x, herbivore.y);
                        if (dist < closestPreyDist) {
                            closestPreyDist = dist;
                            closestPrey = herbivore;
                        }
                    }
                    if (closestPrey) {
                        environment.prey = new Vector(closestPrey.x, closestPrey.y);
                    }
                }

                return environment;
            }

            update() {
                // Energy decay
                const decay = this.type === 'herbivore' ? CONFIG.ENERGY_DECAY_HERBIVORE : CONFIG.ENERGY_DECAY_PREDATOR;
                this.energy -= decay;
                this.age++;
                this.pulse += 0.1;

                // Neural decision making
                const environment = this.perceive();
                const decisionForce = this.makeDecision(environment);
                this.applyForce(decisionForce);

                // Apply velocity limit
                const vel = this.velocity.limit(this.maxSpeed);
                this.velocity = vel;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges (soft boundary)
                if (this.x < -10) this.x = CONFIG.WORLD_WIDTH + 10;
                if (this.x > CONFIG.WORLD_WIDTH + 10) this.x = -10;
                if (this.y < -10) this.y = CONFIG.WORLD_HEIGHT + 10;
                if (this.y > CONFIG.WORLD_HEIGHT + 10) this.y = -10;

                // Update trail
                this.updateTrail();

                // Size based on energy
                this.currentSize = this.size * (0.6 + (this.energy / this.maxEnergy) * 0.4);
            }

            draw(ctx) {
                // Draw trail
                if (this.trail.length > 1) {
                    ctx.save();
                    ctx.lineCap = 'round';
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = (i / this.trail.length) * 0.3;
                        ctx.strokeStyle = this.type === 'herbivore' 
                            ? `rgba(0, 255, 136, ${alpha})` 
                            : `rgba(255, 68, 68, ${alpha})`;
                        ctx.lineWidth = this.currentSize * (i / this.trail.length);
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                // Draw glow
                const pulseSize = this.currentSize + Math.sin(this.pulse) * 1;
                ctx.save();
                ctx.shadowColor = this.baseColor;
                ctx.shadowBlur = 20;
                ctx.fillStyle = this.baseColor;
                ctx.beginPath();
                
                if (this.type === 'herbivore') {
                    // Circle for herbivores
                    ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);
                } else {
                    // Triangle for predators
                    const angle = this.velocity.heading();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    ctx.moveTo(pulseSize * 1.5, 0);
                    ctx.lineTo(-pulseSize, -pulseSize * 0.8);
                    ctx.lineTo(-pulseSize, pulseSize * 0.8);
                    ctx.closePath();
                }
                ctx.fill();
                ctx.restore();

                // Inner core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Energy indicator (subtle ring)
                const energyRatio = this.energy / this.maxEnergy;
                ctx.save();
                ctx.strokeStyle = energyRatio > 0.5 ? 'rgba(0, 255, 136, 0.3)' : 'rgba(255, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize + 4, 0, Math.PI * 2 * energyRatio);
                ctx.stroke();
                ctx.restore();
            }

            canReproduce() {
                return this.energy > CONFIG.REPRODUCTION_THRESHOLD && this.age > 100;
            }

            reproduce() {
                this.energy -= CONFIG.REPRODUCTION_COST;
                const offspring = this.type === 'herbivore' 
                    ? new Herbivore(this.x + random(-20, 20), this.y + random(-20, 20))
                    : new Predator(this.x + random(-20, 20), this.y + random(-20, 20));
                offspring.generation = this.generation + 1;
                offspring.energy = 40;
                return offspring;
            }

            isDead() {
                return this.energy <= 0;
            }

            getAgeInSeconds() {
                return Math.floor((Date.now() - this.birthTime) / 1000);
            }
        }

        class Herbivore extends Creature {
            constructor(x, y) {
                super(x, y, 'herbivore');
            }

            checkCollisions() {
                // Eat food
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    const dist = distance(this.x, this.y, food.x, food.y);
                    if (dist < this.currentSize + food.size + 5) {
                        this.energy = Math.min(this.maxEnergy, this.energy + food.energy);
                        spawnParticles(food.x, food.y, food.color, 5);
                        foods.splice(i, 1);
                    }
                }
            }
        }

        class Predator extends Creature {
            constructor(x, y) {
                super(x, y, 'predator');
            }

            checkCollisions() {
                // Hunt herbivores
                for (let i = herbivores.length - 1; i >= 0; i--) {
                    const prey = herbivores[i];
                    const dist = distance(this.x, this.y, prey.x, prey.y);
                    if (dist < this.currentSize + prey.currentSize + 5) {
                        this.energy = Math.min(this.maxEnergy, this.energy + 40);
                        spawnParticles(prey.x, prey.y, '#00ff88', 12, 4);
                        herbivores.splice(i, 1);
                    }
                }
            }
        }

        // ============================================
        // SIMULATION MANAGEMENT
        // ============================================

        windField = new WindField();

        function initSimulation() {
            herbivores = [];
            predators = [];
            foods = [];
            particles = [];
            generation = 1;
            oldestCreatureAge = 0;

            // Create initial herbivores
            for (let i = 0; i < CONFIG.INITIAL_HERBIVORES; i++) {
                herbivores.push(new Herbivore(
                    random(50, CONFIG.WORLD_WIDTH - 50),
                    random(50, CONFIG.WORLD_HEIGHT - 50)
                ));
            }

            // Create initial predators
            for (let i = 0; i < CONFIG.INITIAL_PREDATORS; i++) {
                predators.push(new Predator(
                    random(50, CONFIG.WORLD_WIDTH - 50),
                    random(50, CONFIG.WORLD_HEIGHT - 50)
                ));
            }

            // Create initial food
            for (let i = 0; i < CONFIG.INITIAL_FOOD; i++) {
                spawnRandomFood();
            }

            windField.init();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            CONFIG.WORLD_WIDTH = canvas.width;
            CONFIG.WORLD_HEIGHT = canvas.height;
            if (windField.cells.length === 0) {
                windField.init();
            }
        }

        function updateStats() {
            document.getElementById('herbivore-count').textContent = herbivores.length;
            document.getElementById('predator-count').textContent = predators.length;
            document.getElementById('food-count').textContent = foods.length;
            document.getElementById('generation-count').textContent = generation;

            // Find oldest creature
            let oldest = 0;
            const allCreatures = [...herbivores, ...predators];
            for (const creature of allCreatures) {
                const age = creature.getAgeInSeconds();
                if (age > oldest) oldest = age;
            }
            oldestCreatureAge = oldest;
            document.getElementById('oldest-creature').textContent = oldest + 's';
        }

        function updateSimulation() {
            if (isPaused) return;

            // Spawn food over time
            if (Math.random() < CONFIG.FOOD_SPAWN_RATE) {
                spawnRandomFood();
            }

            // Update wind field
            windField.update();

            // Update food
            for (const food of foods) {
                food.update();
            }

            // Update herbivores
            for (let i = herbivores.length - 1; i >= 0; i--) {
                const h = herbivores[i];
                h.update();
                h.checkCollisions();

                if (h.isDead()) {
                    spawnParticles(h.x, h.y, '#00ff88', 10);
                    herbivores.splice(i, 1);
                } else if (h.canReproduce() && Math.random() < 0.005 && herbivores.length < 50) {
                    herbivores.push(h.reproduce());
                }
            }

            // Update predators
            for (let i = predators.length - 1; i >= 0; i--) {
                const p = predators[i];
                p.update();
                p.checkCollisions();

                if (p.isDead()) {
                    spawnParticles(p.x, p.y, '#ff4444', 10);
                    predators.splice(i, 1);
                } else if (p.canReproduce() && Math.random() < 0.003 && predators.length < 15) {
                    predators.push(p.reproduce());
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                }
            }

            // Ecosystem regeneration if too few creatures
            if (herbivores.length < 3 && Math.random() < 0.02) {
                herbivores.push(new Herbivore(
                    random(50, CONFIG.WORLD_WIDTH - 50),
                    random(50, CONFIG.WORLD_HEIGHT - 50)
                ));
                generation++;
            }

            if (predators.length === 0 && herbivores.length > 5 && Math.random() < 0.01) {
                predators.push(new Predator(
                    random(50, CONFIG.WORLD_WIDTH - 50),
                    random(50, CONFIG.WORLD_HEIGHT - 50)
                ));
            }

            updateStats();
        }

        function draw() {
            // Clear with trail effect
            ctx.fillStyle = 'rgba(10, 10, 15, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw wind field (subtle)
            windField.draw(ctx);

            // Draw food
            for (const food of foods) {
                food.draw(ctx);
            }

            // Draw herbivores
            for (const h of herbivores) {
                h.draw(ctx);
            }

            // Draw predators
            for (const p of predators) {
                p.draw(ctx);
            }

            // Draw particles
            for (const p of particles) {
                p.draw(ctx);
            }
        }

        function loop() {
            updateSimulation();
            draw();
            frameCount++;
            requestAnimationFrame(loop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    windField.addWind(e.clientX, e.clientY, dx * 0.1, dy * 0.1, 80);
                }
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDragging) {
                const dx = e.clientX - dragStartX;
                const dy = e.clientY - dragStartY;
                const dist = Math.hypot(dx, dy);
                
                // If it was a short drag, spawn food (click)
                if (dist < 10) {
                    spawnFood(e.clientX, e.clientY);
                    spawnParticles(e.clientX, e.clientY, '#ffaa00', 6, 2);
                }
            }
            isDragging = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            isDragging = true;
            dragStartX = touch.clientX;
            dragStartY = touch.clientY;
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;

            if (isDragging) {
                const dx = touch.clientX - dragStartX;
                const dy = touch.clientY - dragStartY;
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    windField.addWind(touch.clientX, touch.clientY, dx * 0.1, dy * 0.1, 80);
                }
                dragStartX = touch.clientX;
                dragStartY = touch.clientY;
            }
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
            if (isDragging) {
                const dx = mouseX - dragStartX;
                const dy = mouseY - dragStartY;
                const dist = Math.hypot(dx, dy);
                
                if (dist < 10) {
                    spawnFood(mouseX, mouseY);
                }
            }
            isDragging = false;
        });

        // Button handlers
        document.getElementById('btn-pause').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('btn-pause').textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            initSimulation();
        });

        document.getElementById('btn-herbivore').addEventListener('click', () => {
            herbivores.push(new Herbivore(
                random(50, CONFIG.WORLD_WIDTH - 50),
                random(50, CONFIG.WORLD_HEIGHT - 50)
            ));
        });

        document.getElementById('btn-predator').addEventListener('click', () => {
            predators.push(new Predator(
                random(50, CONFIG.WORLD_WIDTH - 50),
                random(50, CONFIG.WORLD_HEIGHT - 50)
            ));
        });

        // Hide help tooltip after 10 seconds
        setTimeout(() => {
            document.getElementById('help-tooltip').classList.remove('visible');
        }, 10000);

        // ============================================
        // INITIALIZATION
        // ============================================

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initSimulation();
        loop();

        console.log('ðŸŒ¿ Lumina Ecosystem initialized');
        console.log('Creatures: ' + (CONFIG.INITIAL_HERBIVORES + CONFIG.INITIAL_PREDATORS));
        console.log('Food sources: ' + CONFIG.INITIAL_FOOD);
    </script>
</body>
</html>
