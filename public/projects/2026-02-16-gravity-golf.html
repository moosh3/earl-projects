<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravity Golf - Earl's Workshop</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(100, 150, 255, 0.3), inset 0 0 100px rgba(0, 0, 0, 0.5);
        }
        
        canvas {
            display: block;
            background: radial-gradient(ellipse at center, #0f0f23 0%, #050510 100%);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        
        #ui > * {
            pointer-events: auto;
        }
        
        .panel {
            background: rgba(20, 30, 60, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #64b5f6, #90caf9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #a0b0d0;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #64b5f6;
        }
        
        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #controls {
            display: flex;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #2196f3, #1976d2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background: rgba(100, 100, 150, 0.3);
            border: 1px solid rgba(150, 150, 200, 0.5);
        }
        
        button.secondary:hover {
            background: rgba(100, 100, 150, 0.5);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            color: #90caf9;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #instructions.show {
            opacity: 1;
        }
        
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 30, 60, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 200, 100, 0.5);
            border-radius: 20px;
            padding: 40px 60px;
            text-align: center;
            display: none;
            box-shadow: 0 0 100px rgba(100, 255, 100, 0.3);
        }
        
        #levelComplete h2 {
            font-size: 36px;
            color: #4caf50;
            margin-bottom: 20px;
        }
        
        #levelComplete p {
            font-size: 18px;
            color: #a0b0d0;
            margin-bottom: 10px;
        }
        
        .stars {
            font-size: 40px;
            margin: 20px 0;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 30, 60, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 100, 100, 0.5);
            border-radius: 20px;
            padding: 40px 60px;
            text-align: center;
            display: none;
            box-shadow: 0 0 100px rgba(255, 100, 100, 0.3);
        }
        
        #gameOver h2 {
            font-size: 36px;
            color: #f44336;
            margin-bottom: 20px;
        }
        
        .power-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .power-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #ffeb3b, #f44336);
            width: 0%;
            transition: width 0.05s linear;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="650"></canvas>
        
        <div id="ui">
            <div class="panel">
                <h1>üåå Gravity Golf</h1>
                <div class="stats">
                    <div class="stat">
                        <span class="stat-value" id="levelDisplay">1</span>
                        <span class="stat-label">Level</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value" id="strokeDisplay">0</span>
                        <span class="stat-label">Strokes</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value" id="parDisplay">3</span>
                        <span class="stat-label">Par</span>
                    </div>
                    <div class="stat">
                        <span class="stat-value" id="totalScoreDisplay">0</span>
                        <span class="stat-label">Total</span>
                    </div>
                </div>
            </div>
            
            <div id="controls">
                <button class="secondary" onclick="game.resetBall()">‚Ü∫ Reset Ball</button>
                <button class="secondary" onclick="game.restartLevel()">‚ü≤ Restart Level</button>
            </div>
        </div>
        
        <div id="instructions" class="show">
            Drag and release to shoot ‚Ä¢ Avoid the void ‚Ä¢ Use gravity to your advantage
        </div>
        
        <div class="power-indicator">
            <div class="power-bar" id="powerBar"></div>
        </div>
        
        <div id="levelComplete">
            <h2>üéâ Hole Complete!</h2>
            <p>Strokes: <span id="finalStrokes">0</span> / Par: <span id="finalPar">3</span></p>
            <div class="stars" id="starsDisplay">‚≠ê‚≠ê‚≠ê</div>
            <p id="scoreText">Eagle!</p>
            <button onclick="game.nextLevel()">Next Level ‚Üí</button>
        </div>
        
        <div id="gameOver">
            <h2>üèÜ Game Complete!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p id="finalRank">You're a Gravity Master!</p>
            <button onclick="game.restartGame()">Play Again ‚Ü∫</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const G = 0.8; // Gravitational constant
        const FRICTION = 0.985;
        const MIN_VELOCITY = 0.05;
        const MAX_POWER = 25;
        
        // Levels configuration
        const levels = [
            {
                par: 3,
                start: { x: 100, y: 325 },
                hole: { x: 800, y: 325, radius: 20 },
                planets: [
                    { x: 450, y: 325, mass: 2000, radius: 40, color: '#4fc3f7' }
                ],
                obstacles: [],
                stars: [{ x: 450, y: 150 }, { x: 450, y: 500 }]
            },
            {
                par: 4,
                start: { x: 80, y: 100 },
                hole: { x: 820, y: 550, radius: 18 },
                planets: [
                    { x: 300, y: 200, mass: 1500, radius: 35, color: '#ff7043' },
                    { x: 600, y: 400, mass: 1800, radius: 38, color: '#ab47bc' }
                ],
                obstacles: [
                    { x: 450, y: 325, width: 20, height: 200 }
                ],
                stars: [{ x: 150, y: 500 }, { x: 750, y: 150 }]
            },
            {
                par: 5,
                start: { x: 100, y: 550 },
                hole: { x: 800, y: 100, radius: 18 },
                planets: [
                    { x: 200, y: 300, mass: 2000, radius: 45, color: '#66bb6a' },
                    { x: 500, y: 200, mass: 2500, radius: 50, color: '#42a5f5' },
                    { x: 700, y: 400, mass: 1800, radius: 40, color: '#ffa726' }
                ],
                obstacles: [
                    { x: 350, y: 0, width: 30, height: 350 },
                    { x: 550, y: 300, width: 30, height: 350 }
                ],
                stars: [{ x: 500, y: 450 }]
            },
            {
                par: 4,
                start: { x: 50, y: 325 },
                hole: { x: 850, y: 325, radius: 16 },
                planets: [
                    { x: 250, y: 200, mass: 1500, radius: 30, color: '#ec407a' },
                    { x: 450, y: 450, mass: 1500, radius: 30, color: '#26c6da' },
                    { x: 650, y: 200, mass: 1500, radius: 30, color: '#d4e157' }
                ],
                obstacles: [
                    { x: 350, y: 250, width: 200, height: 20 },
                    { x: 350, y: 380, width: 200, height: 20 }
                ],
                stars: [{ x: 450, y: 100 }, { x: 450, y: 550 }, { x: 750, y: 325 }]
            },
            {
                par: 6,
                start: { x: 450, y: 600 },
                hole: { x: 450, y: 50, radius: 15 },
                planets: [
                    { x: 200, y: 400, mass: 3000, radius: 55, color: '#7e57c2' },
                    { x: 700, y: 400, mass: 3000, radius: 55, color: '#5c6bc0' },
                    { x: 450, y: 250, mass: 2000, radius: 40, color: '#26a69a' },
                    { x: 300, y: 150, mass: 1200, radius: 25, color: '#ffca28' },
                    { x: 600, y: 150, mass: 1200, radius: 25, color: '#ffca28' }
                ],
                obstacles: [
                    { x: 400, y: 450, width: 100, height: 15 },
                    { x: 0, y: 300, width: 150, height: 15 },
                    { x: 750, y: 300, width: 150, height: 15 }
                ],
                stars: [{ x: 100, y: 100 }, { x: 800, y: 100 }, { x: 450, y: 350 }]
            }
        ];
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.03;
                this.color = color;
                this.size = 2 + Math.random() * 4;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.98;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Game {
            constructor() {
                this.level = 0;
                this.strokes = 0;
                this.totalScore = 0;
                this.ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 10 };
                this.aiming = false;
                this.aimStart = { x: 0, y: 0 };
                this.aimCurrent = { x: 0, y: 0 };
                this.ballMoving = false;
                this.particles = [];
                this.starsCollected = [];
                this.trajectory = [];
                
                this.setupInput();
                this.loadLevel(0);
                this.loop();
            }
            
            setupInput() {
                canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.onMouseUp(e);
                }, { passive: false });
            }
            
            getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            onMouseDown(e) {
                if (this.ballMoving || document.getElementById('levelComplete').style.display === 'block') return;
                
                const pos = this.getMousePos(e);
                const dist = Math.hypot(pos.x - this.ball.x, pos.y - this.ball.y);
                
                if (dist < 50) {
                    this.aiming = true;
                    this.aimStart = { x: this.ball.x, y: this.ball.y };
                    this.aimCurrent = pos;
                }
            }
            
            onMouseMove(e) {
                if (!this.aiming) return;
                this.aimCurrent = this.getMousePos(e);
                this.calculateTrajectory();
            }
            
            onMouseUp(e) {
                if (!this.aiming) return;
                
                const dx = this.aimStart.x - this.aimCurrent.x;
                const dy = this.aimStart.y - this.aimCurrent.y;
                const power = Math.min(Math.hypot(dx, dy) * 0.15, MAX_POWER);
                
                if (power > 1) {
                    const angle = Math.atan2(dy, dx);
                    this.ball.vx = Math.cos(angle) * power;
                    this.ball.vy = Math.sin(angle) * power;
                    this.ballMoving = true;
                    this.strokes++;
                    this.updateUI();
                    
                    // Create launch particles
                    for (let i = 0; i < 10; i++) {
                        this.particles.push(new Particle(this.ball.x, this.ball.y, '#64b5f6'));
                    }
                }
                
                this.aiming = false;
                this.trajectory = [];
                document.getElementById('instructions').classList.remove('show');
            }
            
            calculateTrajectory() {
                this.trajectory = [];
                const dx = this.aimStart.x - this.aimCurrent.x;
                const dy = this.aimStart.y - this.aimCurrent.y;
                const power = Math.min(Math.hypot(dx, dy) * 0.15, MAX_POWER);
                
                if (power <= 1) return;
                
                const angle = Math.atan2(dy, dx);
                let simX = this.ball.x;
                let simY = this.ball.y;
                let simVx = Math.cos(angle) * power;
                let simVy = Math.sin(angle) * power;
                
                for (let i = 0; i < 30; i++) {
                    // Apply gravity from planets
                    for (const planet of levels[this.level].planets) {
                        const pdx = planet.x - simX;
                        const pdy = planet.y - simY;
                        const dist = Math.hypot(pdx, pdy);
                        if (dist > planet.radius + this.ball.radius) {
                            const force = (G * planet.mass) / (dist * dist);
                            simVx += (pdx / dist) * force * 0.5;
                            simVy += (pdy / dist) * force * 0.5;
                        }
                    }
                    
                    simX += simVx * 0.5;
                    simY += simVy * 0.5;
                    
                    this.trajectory.push({ x: simX, y: simY });
                }
            }
            
            loadLevel(levelIndex) {
                this.level = levelIndex;
                const level = levels[levelIndex];
                this.ball.x = level.start.x;
                this.ball.y = level.start.y;
                this.ball.vx = 0;
                this.ball.vy = 0;
                this.ballMoving = false;
                this.aiming = false;
                this.strokes = 0;
                this.starsCollected = [];
                this.trajectory = [];
                this.updateUI();
                
                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
            }
            
            update() {
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.update();
                    return p.life > 0;
                });
                
                if (!this.ballMoving) return;
                
                // Apply gravity from planets
                for (const planet of levels[this.level].planets) {
                    const dx = planet.x - this.ball.x;
                    const dy = planet.y - this.ball.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > planet.radius + this.ball.radius) {
                        const force = (G * planet.mass) / (dist * dist);
                        this.ball.vx += (dx / dist) * force;
                        this.ball.vy += (dy / dist) * force;
                    }
                }
                
                // Apply friction
                this.ball.vx *= FRICTION;
                this.ball.vy *= FRICTION;
                
                // Update position
                this.ball.x += this.ball.vx;
                this.ball.y += this.ball.vy;
                
                // Trail particles
                if (Math.random() < 0.3 && Math.hypot(this.ball.vx, this.ball.vy) > 2) {
                    this.particles.push(new Particle(this.ball.x, this.ball.y, '#90caf9'));
                }
                
                // Check planet collisions
                for (const planet of levels[this.level].planets) {
                    const dx = planet.x - this.ball.x;
                    const dy = planet.y - this.ball.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < planet.radius + this.ball.radius) {
                        // Bounce off planet
                        const normalX = dx / dist;
                        const normalY = dy / dist;
                        const dot = this.ball.vx * normalX + this.ball.vy * normalY;
                        this.ball.vx -= 2 * dot * normalX * 0.7;
                        this.ball.vy -= 2 * dot * normalY * 0.7;
                        
                        // Push out
                        const overlap = planet.radius + this.ball.radius - dist;
                        this.ball.x -= normalX * overlap;
                        this.ball.y -= normalY * overlap;
                        
                        // Collision particles
                        for (let i = 0; i < 5; i++) {
                            this.particles.push(new Particle(
                                this.ball.x + normalX * this.ball.radius,
                                this.ball.y + normalY * this.ball.radius,
                                planet.color
                            ));
                        }
                    }
                }
                
                // Check obstacle collisions
                for (const obs of levels[this.level].obstacles) {
                    if (this.ball.x + this.ball.radius > obs.x &&
                        this.ball.x - this.ball.radius < obs.x + obs.width &&
                        this.ball.y + this.ball.radius > obs.y &&
                        this.ball.y - this.ball.radius < obs.y + obs.height) {
                        
                        // Simple bounce
                        const centerX = obs.x + obs.width / 2;
                        const centerY = obs.y + obs.height / 2;
                        const dx = this.ball.x - centerX;
                        const dy = this.ball.y - centerY;
                        
                        if (Math.abs(dx) / obs.width > Math.abs(dy) / obs.height) {
                            this.ball.vx *= -0.7;
                            this.ball.x = dx > 0 ? obs.x + obs.width + this.ball.radius : obs.x - this.ball.radius;
                        } else {
                            this.ball.vy *= -0.7;
                            this.ball.y = dy > 0 ? obs.y + obs.height + this.ball.radius : obs.y - this.ball.radius;
                        }
                    }
                }
                
                // Check star collection
                for (let i = 0; i < levels[this.level].stars.length; i++) {
                    if (this.starsCollected.includes(i)) continue;
                    const star = levels[this.level].stars[i];
                    const dist = Math.hypot(this.ball.x - star.x, this.ball.y - star.y);
                    if (dist < 25) {
                        this.starsCollected.push(i);
                        for (let j = 0; j < 15; j++) {
                            this.particles.push(new Particle(star.x, star.y, '#ffd700'));
                        }
                    }
                }
                
                // Check hole
                const hole = levels[this.level].hole;
                const distToHole = Math.hypot(this.ball.x - hole.x, this.ball.y - hole.y);
                if (distToHole < hole.radius && Math.hypot(this.ball.vx, this.ball.vy) < 8) {
                    this.ballInHole();
                }
                
                // Check bounds
                if (this.ball.x < -50 || this.ball.x > canvas.width + 50 ||
                    this.ball.y < -50 || this.ball.y > canvas.height + 50) {
                    this.resetBall();
                }
                
                // Stop if slow
                if (Math.hypot(this.ball.vx, this.ball.vy) < MIN_VELOCITY) {
                    this.ballMoving = false;
                    this.ball.vx = 0;
                    this.ball.vy = 0;
                }
            }
            
            ballInHole() {
                this.ballMoving = false;
                
                // Success particles
                for (let i = 0; i < 30; i++) {
                    this.particles.push(new Particle(this.ball.x, this.ball.y, '#4caf50'));
                }
                
                const par = levels[this.level].par;
                const diff = this.strokes - par;
                let stars = 3;
                let text = 'Hole in One!';
                
                if (this.strokes === 1) {
                    text = 'Hole in One! üéØ';
                } else if (diff <= -2) {
                    text = 'Eagle! ü¶Ö';
                } else if (diff === -1) {
                    text = 'Birdie! üê¶';
                } else if (diff === 0) {
                    text = 'Par! ‚úÖ';
                    stars = 2;
                } else if (diff === 1) {
                    text = 'Bogey';
                    stars = 1;
                } else {
                    text = 'Double Bogey';
                    stars = 1;
                }
                
                this.totalScore += this.strokes;
                
                document.getElementById('finalStrokes').textContent = this.strokes;
                document.getElementById('finalPar').textContent = par;
                document.getElementById('starsDisplay').textContent = '‚≠ê'.repeat(stars);
                document.getElementById('scoreText').textContent = text;
                document.getElementById('levelComplete').style.display = 'block';
            }
            
            nextLevel() {
                if (this.level < levels.length - 1) {
                    this.loadLevel(this.level + 1);
                } else {
                    document.getElementById('levelComplete').style.display = 'none';
                    document.getElementById('finalScore').textContent = this.totalScore;
                    
                    const totalPar = levels.reduce((sum, l) => sum + l.par, 0);
                    const diff = this.totalScore - totalPar;
                    let rank = '';
                    if (diff <= -5) rank = 'üèÜ Legendary! You mastered gravity itself!';
                    else if (diff <= 0) rank = 'üåü Gravity Master! Exceptional play!';
                    else if (diff <= 3) rank = 'üëç Solid performance! Well done!';
                    else rank = 'üöÄ Keep practicing! The cosmos awaits!';
                    
                    document.getElementById('finalRank').textContent = rank;
                    document.getElementById('gameOver').style.display = 'block';
                }
            }
            
            resetBall() {
                const level = levels[this.level];
                this.ball.x = level.start.x;
                this.ball.y = level.start.y;
                this.ball.vx = 0;
                this.ball.vy = 0;
                this.ballMoving = false;
                this.trajectory = [];
            }
            
            restartLevel() {
                this.loadLevel(this.level);
            }
            
            restartGame() {
                this.totalScore = 0;
                this.loadLevel(0);
            }
            
            updateUI() {
                document.getElementById('levelDisplay').textContent = this.level + 1;
                document.getElementById('strokeDisplay').textContent = this.strokes;
                document.getElementById('parDisplay').textContent = levels[this.level].par;
                document.getElementById('totalScoreDisplay').textContent = this.totalScore;
                
                // Update power bar
                if (this.aiming) {
                    const dx = this.aimStart.x - this.aimCurrent.x;
                    const dy = this.aimStart.y - this.aimCurrent.y;
                    const power = Math.min(Math.hypot(dx, dy) * 0.15, MAX_POWER);
                    const percent = (power / MAX_POWER) * 100;
                    document.getElementById('powerBar').style.width = percent + '%';
                } else {
                    document.getElementById('powerBar').style.width = '0%';
                }
            }
            
            draw() {
                // Clear canvas
                ctx.fillStyle = '#050510';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars background
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 137.5) % canvas.width;
                    const y = (i * 71.3) % canvas.height;
                    const size = (i % 3) * 0.5 + 0.5;
                    const alpha = 0.3 + (i % 5) * 0.1;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                const level = levels[this.level];
                
                // Draw hole
                ctx.fillStyle = '#1a1a2e';
                ctx.beginPath();
                ctx.arc(level.hole.x, level.hole.y, level.hole.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw hole glow
                const holeGradient = ctx.createRadialGradient(
                    level.hole.x, level.hole.y, 0,
                    level.hole.x, level.hole.y, level.hole.radius * 2
                );
                holeGradient.addColorStop(0, 'rgba(76, 175, 80, 0.3)');
                holeGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                ctx.fillStyle = holeGradient;
                ctx.beginPath();
                ctx.arc(level.hole.x, level.hole.y, level.hole.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw obstacles
                ctx.fillStyle = 'rgba(100, 100, 120, 0.8)';
                for (const obs of level.obstacles) {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.strokeStyle = 'rgba(150, 150, 170, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
                }
                
                // Draw planets with glow
                for (const planet of level.planets) {
                    // Planet glow
                    const gradient = ctx.createRadialGradient(
                        planet.x, planet.y, 0,
                        planet.x, planet.y, planet.radius * 2.5
                    );
                    gradient.addColorStop(0, planet.color + '60');
                    gradient.addColorStop(0.5, planet.color + '20');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(planet.x, planet.y, planet.radius * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Planet body
                    const bodyGradient = ctx.createRadialGradient(
                        planet.x - planet.radius * 0.3, planet.y - planet.radius * 0.3, 0,
                        planet.x, planet.y, planet.radius
                    );
                    bodyGradient.addColorStop(0, '#fff');
                    bodyGradient.addColorStop(0.3, planet.color);
                    bodyGradient.addColorStop(1, planet.color + '80');
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw collectible stars
                for (let i = 0; i < level.stars.length; i++) {
                    if (this.starsCollected.includes(i)) continue;
                    const star = level.stars[i];
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 20;
                    this.drawStar(ctx, star.x, star.y, 5, 12 * pulse, 6 * pulse);
                    ctx.shadowBlur = 0;
                }
                
                // Draw trajectory preview
                if (this.trajectory.length > 0) {
                    ctx.strokeStyle = 'rgba(100, 181, 246, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.ball.x, this.ball.y);
                    for (const point of this.trajectory) {
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw aim line
                if (this.aiming) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.ball.x, this.ball.y);
                    ctx.lineTo(this.aimCurrent.x, this.aimCurrent.y);
                    ctx.stroke();
                    
                    // Draw power indicator
                    const dx = this.aimStart.x - this.aimCurrent.x;
                    const dy = this.aimStart.y - this.aimCurrent.y;
                    const power = Math.min(Math.hypot(dx, dy) * 0.15, MAX_POWER);
                    const angle = Math.atan2(dy, dx);
                    
                    ctx.strokeStyle = `hsl(${120 - power * 4}, 100%, 50%)`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.ball.x, this.ball.y);
                    ctx.lineTo(
                        this.ball.x + Math.cos(angle) * power * 8,
                        this.ball.y + Math.sin(angle) * power * 8
                    );
                    ctx.stroke();
                }
                
                // Draw particles
                for (const p of this.particles) {
                    p.draw(ctx);
                }
                
                // Draw ball
                const ballGradient = ctx.createRadialGradient(
                    this.ball.x - 3, this.ball.y - 3, 0,
                    this.ball.x, this.ball.y, this.ball.radius
                );
                ballGradient.addColorStop(0, '#fff');
                ballGradient.addColorStop(0.5, '#e3f2fd');
                ballGradient.addColorStop(1, '#64b5f6');
                ctx.fillStyle = ballGradient;
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ball glow when moving
                if (this.ballMoving) {
                    ctx.shadowColor = '#64b5f6';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Draw start position indicator
                ctx.strokeStyle = 'rgba(100, 181, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(level.start.x, level.start.y, 15, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                let step = Math.PI / spikes;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
                ctx.fill();
            }
            
            loop() {
                this.update();
                this.updateUI();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }
        
        // Start game
        const game = new Game();
    </script>
</body>
</html>
