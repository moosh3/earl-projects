<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Interference Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0d1117 0%, #0a0a0f 100%);
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .title-overlay h1 {
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96e6a1, #ff6b6b);
            background-size: 300% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 4s linear infinite;
            text-shadow: 0 0 30px rgba(78, 205, 196, 0.3);
        }

        .title-overlay .subtitle {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            letter-spacing: 0.2em;
            margin-top: 5px;
        }

        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 300% center; }
        }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
            min-width: 180px;
        }

        .stats-panel h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .stat-value.sources { color: #4ecdc4; }
        .stat-value.frequency { color: #ff6b6b; }
        .stat-value.amplitude { color: #ffe66d; }
        .stat-value.speed { color: #96e6a1; }

        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .btn:hover {
            background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.primary {
            background: linear-gradient(145deg, #4ecdc4, #44a08d);
            border-color: #4ecdc4;
            color: #0a0a0f;
        }

        .btn.primary:hover {
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.4);
        }

        .btn.danger {
            background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
            border-color: #ff6b6b;
            color: #fff;
        }

        .btn.danger:hover {
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4);
        }

        .btn.warning {
            background: linear-gradient(145deg, #ffe66d, #f4d03f);
            border-color: #ffe66d;
            color: #0a0a0f;
        }

        .btn.warning:hover {
            box-shadow: 0 4px 20px rgba(255, 230, 109, 0.4);
        }

        /* Slider Panel */
        .slider-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
            width: 220px;
        }

        .slider-panel h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .slider-container {
            margin: 14px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 6px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
            border: none;
        }

        /* Presets Panel */
        .presets-panel {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px 20px;
            z-index: 100;
            max-width: 200px;
        }

        .presets-panel h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preset-btn {
            display: block;
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            margin: 6px 0;
            transition: all 0.2s ease;
            text-align: left;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Help Tooltip */
        .help-tooltip {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .help-tooltip.hidden {
            opacity: 0;
        }

        .help-tooltip span {
            margin: 0 10px;
        }

        .help-tooltip .key {
            color: #4ecdc4;
            font-weight: 600;
        }

        /* Wave Source Info */
        .source-info {
            position: absolute;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        .source-info.visible {
            display: block;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .title-overlay h1 {
                font-size: 1.2rem;
            }
            .stats-panel {
                top: 70px;
                left: 10px;
                padding: 10px 14px;
                min-width: 130px;
            }
            .slider-panel {
                top: auto;
                bottom: 180px;
                right: 10px;
                left: 10px;
                width: auto;
                max-width: none;
            }
            .presets-panel {
                display: none;
            }
            .control-panel {
                bottom: 10px;
                padding: 10px 15px;
                gap: 8px;
            }
            .btn {
                padding: 8px 12px;
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <h1>Wave Sandbox</h1>
        <div class="subtitle">Interactive Wave Interference Simulation</div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <h3>Simulation Stats</h3>
        <div class="stat-row">
            <span class="stat-label">Sources</span>
            <span class="stat-value sources" id="source-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Frequency</span>
            <span class="stat-value frequency" id="freq-display">2.0 Hz</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Amplitude</span>
            <span class="stat-value amplitude" id="amp-display">50%</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Wave Speed</span>
            <span class="stat-value speed" id="speed-display">100%</span>
        </div>
    </div>

    <!-- Slider Panel -->
    <div class="slider-panel">
        <h3>Wave Properties</h3>
        <div class="slider-container">
            <div class="slider-label">
                <span>Frequency</span>
                <span id="freq-val">2.0</span>
            </div>
            <input type="range" class="slider" id="freq-slider" min="0.5" max="5" step="0.1" value="2">
        </div>
        <div class="slider-container">
            <div class="slider-label">
                <span>Amplitude</span>
                <span id="amp-val">0.5</span>
            </div>
            <input type="range" class="slider" id="amp-slider" min="0.1" max="1" step="0.1" value="0.5">
        </div>
        <div class="slider-container">
            <div class="slider-label">
                <span>Wave Speed</span>
                <span id="speed-val">1.0</span>
            </div>
            <input type="range" class="slider" id="speed-slider" min="0.2" max="2" step="0.1" value="1">
        </div>
        <div class="slider-container">
            <div class="slider-label">
                <span>Resolution</span>
                <span id="res-val">Medium</span>
            </div>
            <input type="range" class="slider" id="res-slider" min="1" max="4" step="1" value="2">
        </div>
    </div>

    <!-- Presets Panel -->
    <div class="presets-panel">
        <h3>Presets</h3>
        <button class="preset-btn" data-preset="double-slit">Double Slit</button>
        <button class="preset-btn" data-preset="ripple">Ripple Tank</button>
        <button class="preset-btn" data-preset="interference">Interference</button>
        <button class="preset-btn" data-preset="single">Single Source</button>
        <button class="preset-btn" data-preset="array">Linear Array</button>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <button class="btn primary" id="btn-pause">Pause</button>
        <button class="btn warning" id="btn-clear">Clear All</button>
        <button class="btn danger" id="btn-erase">Erase Mode</button>
    </div>

    <!-- Help Tooltip -->
    <div class="help-tooltip" id="help-tooltip">
        <span><span class="key">Click</span> add source</span>
        <span><span class="key">Drag</span> move source</span>
        <span><span class="key">Shift+Click</span> delete</span>
    </div>

    <script>
        // ============================================
        // WAVE INTERFERENCE SANDBOX
        // Interactive wave physics simulation
        // ============================================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // Configuration
        const CONFIG = {
            GRID_SPACING: 8,
            DAMPING: 0.99,
            WAVE_SPEED: 2,
            COLOR_SHIFT_SPEED: 0.5,
            SHOW_GRID: false,
            MAX_SOURCES: 20
        };

        // Simulation state
        let isPaused = false;
        let isEraseMode = false;
        let frameCount = 0;
        let time = 0;
        let mouseX = 0;
        let mouseY = 0;
        let isDragging = false;
        let draggedSource = null;
        let colorOffset = 0;

        // Wave parameters (controlled by sliders)
        let waveParams = {
            frequency: 2.0,
            amplitude: 0.5,
            speed: 1.0,
            resolution: 2
        };

        // Entities
        let sources = [];
        let gridWidth = 0;
        let gridHeight = 0;

        // Offscreen canvas for performance
        let offscreenCanvas = null;
        let offscreenCtx = null;
        let imageData = null;
        let pixels = null;

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function distance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        // ============================================
        // COLOR FUNCTIONS
        // ============================================

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function getWaveColor(amplitude, offset = 0) {
            // Normalize amplitude to 0-1 range
            const normalized = clamp((amplitude + 1) / 2, 0, 1);
            
            // Create smooth color gradient based on amplitude
            // Using HSV for smooth transitions
            const hue = (normalized * 0.7 + offset) % 1.0;
            const saturation = 0.8 + normalized * 0.2;
            const value = 0.3 + normalized * 0.7;
            
            return hsvToRgb(hue, saturation, value);
        }

        // ============================================
        // WAVE SOURCE CLASS
        // ============================================

        class WaveSource {
            constructor(x, y, phase = 0) {
                this.x = x;
                this.y = y;
                this.phase = phase;
                this.id = Math.random().toString(36).substr(2, 9);
                this.pulsePhase = 0;
                this.isHovered = false;
            }

            getAmplitudeAt(px, py, t) {
                const dist = distance(this.x, this.y, px, py);
                const k = waveParams.frequency * 0.1; // wave number
                const omega = waveParams.frequency; // angular frequency
                const waveSpeed = waveParams.speed * CONFIG.WAVE_SPEED;
                
                // Distance-based amplitude decay
                const decay = 1 / (1 + dist * 0.005);
                
                // Wave equation: A * sin(k*r - Ï‰*t + Ï†) * decay
                const wavePhase = k * dist - omega * t * 0.05 + this.phase;
                return waveParams.amplitude * Math.sin(wavePhase) * decay;
            }

            update() {
                this.pulsePhase += 0.1;
            }

            draw(ctx) {
                const pulseSize = 8 + Math.sin(this.pulsePhase) * 3;
                const glowSize = 20 + Math.sin(this.pulsePhase) * 5;
                
                // Outer glow
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                gradient.addColorStop(0, 'rgba(78, 205, 196, 0.8)');
                gradient.addColorStop(0.5, 'rgba(78, 205, 196, 0.3)');
                gradient.addColorStop(1, 'rgba(78, 205, 196, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Pulsing ring
                ctx.strokeStyle = 'rgba(78, 205, 196, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // Hover indicator
                if (this.isHovered) {
                    ctx.strokeStyle = '#ffe66d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            contains(x, y) {
                return distance(this.x, this.y, x, y) < 20;
            }
        }

        // ============================================
        // SIMULATION MANAGEMENT
        // ============================================

        function initGrid() {
            const spacing = CONFIG.GRID_SPACING * (5 - waveParams.resolution);
            gridWidth = Math.ceil(canvas.width / spacing) + 1;
            gridHeight = Math.ceil(canvas.height / spacing) + 1;
        }

        function createOffscreenBuffer() {
            offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });
            imageData = offscreenCtx.createImageData(canvas.width, canvas.height);
            pixels = imageData.data;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createOffscreenBuffer();
            initGrid();
        }

        function updateWaveParams() {
            waveParams.frequency = parseFloat(document.getElementById('freq-slider').value);
            waveParams.amplitude = parseFloat(document.getElementById('amp-slider').value);
            waveParams.speed = parseFloat(document.getElementById('speed-slider').value);
            waveParams.resolution = parseInt(document.getElementById('res-slider').value);
            
            document.getElementById('freq-val').textContent = waveParams.frequency.toFixed(1);
            document.getElementById('amp-val').textContent = waveParams.amplitude.toFixed(1);
            document.getElementById('speed-val').textContent = waveParams.speed.toFixed(1);
            
            const resLabels = ['Low', 'Medium-Low', 'Medium', 'High'];
            document.getElementById('res-val').textContent = resLabels[waveParams.resolution - 1];
            
            document.getElementById('freq-display').textContent = waveParams.frequency.toFixed(1) + ' Hz';
            document.getElementById('amp-display').textContent = Math.round(waveParams.amplitude * 100) + '%';
            document.getElementById('speed-display').textContent = Math.round(waveParams.speed * 100) + '%';
            
            initGrid();
        }

        function updateStats() {
            document.getElementById('source-count').textContent = sources.length;
        }

        // ============================================
        // WAVE CALCULATION
        // ============================================

        function calculateWaveAt(x, y, t) {
            let totalAmplitude = 0;
            for (const source of sources) {
                totalAmplitude += source.getAmplitudeAt(x, y, t);
            }
            // Normalize to prevent clipping
            return clamp(totalAmplitude, -1, 1);
        }

        function renderWaves() {
            const spacing = CONFIG.GRID_SPACING * (5 - waveParams.resolution);
            const invSpacing = 1 / spacing;
            
            // Clear pixels
            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = 10;     // R
                pixels[i + 1] = 10; // G
                pixels[i + 2] = 15; // B
                pixels[i + 3] = 255; // A
            }
            
            // Calculate wave values at grid points
            for (let gy = 0; gy < gridHeight; gy++) {
                for (let gx = 0; gx < gridWidth; gx++) {
                    const x = gx * spacing;
                    const y = gy * spacing;
                    
                    // Skip if outside canvas bounds
                    if (x >= canvas.width || y >= canvas.height) continue;
                    
                    const amplitude = calculateWaveAt(x, y, time);
                    const color = getWaveColor(amplitude, colorOffset);
                    
                    // Fill a block of pixels for this grid point
                    const blockSize = Math.ceil(spacing);
                    for (let dy = 0; dy < blockSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < blockSize && x + dx < canvas.width; dx++) {
                            const px = Math.floor(x + dx);
                            const py = Math.floor(y + dy);
                            const idx = (py * canvas.width + px) * 4;
                            
                            pixels[idx] = color.r;
                            pixels[idx + 1] = color.g;
                            pixels[idx + 2] = color.b;
                        }
                    }
                }
            }
            
            // Put image data
            offscreenCtx.putImageData(imageData, 0, 0);
            
            // Draw to main canvas
            ctx.drawImage(offscreenCanvas, 0, 0);
        }

        // ============================================
        // PRESETS
        // ============================================

        function loadPreset(presetName) {
            sources = [];
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            switch (presetName) {
                case 'double-slit':
                    // Barrier with two slits
                    for (let y = 100; y < canvas.height - 100; y += 20) {
                        if (Math.abs(y - cy + 40) > 25 && Math.abs(y - cy - 40) > 25) {
                            // Create virtual barrier sources (phased to cancel)
                            // Actually, let's just put sources at the slits
                        }
                    }
                    // Two sources for the slits
                    sources.push(new WaveSource(cx - 200, cy - 40));
                    sources.push(new WaveSource(cx - 200, cy + 40));
                    // Set parameters
                    document.getElementById('freq-slider').value = 1.5;
                    break;
                    
                case 'ripple':
                    // Single source in center
                    sources.push(new WaveSource(cx, cy));
                    document.getElementById('freq-slider').value = 2;
                    break;
                    
                case 'interference':
                    // Two sources side by side
                    sources.push(new WaveSource(cx - 100, cy));
                    sources.push(new WaveSource(cx + 100, cy));
                    document.getElementById('freq-slider').value = 2.5;
                    break;
                    
                case 'single':
                    sources.push(new WaveSource(cx, cy));
                    break;
                    
                case 'array':
                    // Linear array of sources
                    const count = 5;
                    const spacing = 60;
                    const startY = cy - (count - 1) * spacing / 2;
                    for (let i = 0; i < count; i++) {
                        sources.push(new WaveSource(cx - 150, startY + i * spacing));
                    }
                    document.getElementById('freq-slider').value = 1.8;
                    break;
            }
            
            updateWaveParams();
            updateStats();
        }

        // ============================================
        // MAIN LOOP
        // ============================================

        function update() {
            if (!isPaused) {
                time += 1;
                colorOffset += 0.001;
            }
            
            for (const source of sources) {
                source.update();
            }
            
            updateStats();
        }

        function draw() {
            // Render wave field
            renderWaves();
            
            // Draw sources on top
            for (const source of sources) {
                source.draw(ctx);
            }
            
            // Draw drag line
            if (isDragging && draggedSource) {
                ctx.strokeStyle = 'rgba(255, 230, 109, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(draggedSource.x, draggedSource.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Erase mode cursor
            if (isEraseMode) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function loop() {
            update();
            draw();
            frameCount++;
            requestAnimationFrame(loop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on existing source
            const clickedSource = sources.find(s => s.contains(x, y));
            
            if (isEraseMode || e.shiftKey) {
                // Delete mode
                if (clickedSource) {
                    sources = sources.filter(s => s !== clickedSource);
                }
            } else if (clickedSource) {
                // Start dragging
                isDragging = true;
                draggedSource = clickedSource;
            } else {
                // Add new source
                if (sources.length < CONFIG.MAX_SOURCES) {
                    sources.push(new WaveSource(x, y));
                }
            }
            
            mouseX = x;
            mouseY = y;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            // Update hover states
            for (const source of sources) {
                source.isHovered = source.contains(mouseX, mouseY);
            }
            
            // Dragging
            if (isDragging && draggedSource) {
                draggedSource.x = mouseX;
                draggedSource.y = mouseY;
            }
            
            canvas.style.cursor = isEraseMode ? 'crosshair' : 
                                 sources.some(s => s.isHovered) ? 'move' : 'default';
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            draggedSource = null;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            draggedSource = null;
            for (const source of sources) {
                source.isHovered = false;
            }
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const clickedSource = sources.find(s => s.contains(x, y));
            
            if (clickedSource) {
                isDragging = true;
                draggedSource = clickedSource;
            } else if (sources.length < CONFIG.MAX_SOURCES) {
                sources.push(new WaveSource(x, y));
            }
            
            mouseX = x;
            mouseY = y;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            
            if (isDragging && draggedSource) {
                draggedSource.x = mouseX;
                draggedSource.y = mouseY;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
            draggedSource = null;
        });

        // ============================================
        // UI CONTROLS
        // ============================================

        // Sliders
        ['freq-slider', 'amp-slider', 'speed-slider', 'res-slider'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateWaveParams);
        });

        // Buttons
        document.getElementById('btn-pause').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('btn-pause').textContent = isPaused ? 'Resume' : 'Pause';
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            sources = [];
        });

        document.getElementById('btn-erase').addEventListener('click', () => {
            isEraseMode = !isEraseMode;
            const btn = document.getElementById('btn-erase');
            btn.textContent = isEraseMode ? 'Exit Erase' : 'Erase Mode';
            btn.classList.toggle('danger', isEraseMode);
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                loadPreset(btn.dataset.preset);
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    document.getElementById('btn-pause').click();
                    break;
                case 'c':
                case 'C':
                    document.getElementById('btn-clear').click();
                    break;
                case 'e':
                case 'E':
                    document.getElementById('btn-erase').click();
                    break;
                case '1':
                    loadPreset('ripple');
                    break;
                case '2':
                    loadPreset('interference');
                    break;
                case '3':
                    loadPreset('double-slit');
                    break;
                case '4':
                    loadPreset('array');
                    break;
            }
        });

        // Hide help tooltip after 8 seconds
        setTimeout(() => {
            document.getElementById('help-tooltip').classList.add('hidden');
        }, 8000);

        // ============================================
        // INITIALIZATION
        // ============================================

        window.addEventListener('resize', resizeCanvas);
        
        resizeCanvas();
        updateWaveParams();
        loadPreset('ripple');
        loop();

        console.log('ðŸŒŠ Wave Interference Sandbox initialized');
        console.log('Sources: ' + sources.length);
        console.log('Grid: ' + gridWidth + 'x' + gridHeight);
    </script>
</body>
</html>